1ï¸âƒ£ What REALLY happens in a class  
class User {  
  constructor(email, password) {  
    this.email = email;  
    this.password = password; // âœ… setter is called  
  }  

  get password() {  
    return this._password.toUpperCase();  
  }  

  set password(val) {  
    this._password = val;  
  }  
}  

ğŸ” Execution Order  

1. JS creates User.prototype  
2. get password & set password are placed on prototype  
3. constructor() runs  
4. this.password = password:  
   -  JS checks this â†’ no password  
   -  Checks prototype â†’ setter found  
   -  ğŸ‘‰ setter runs  

âœ” Output  

code  

A1ABC923  

ğŸ”‘ Key Rule  

In class, getters/setters exist before object creation, so assignments inside constructor always hit the setter.  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  

2ï¸âƒ£ Why constructor assignment is NOT â€œoverriddenâ€  

js  

this.password = password;  

âŒ This line is not ignored  
âŒ It is not overridden  

âœ” It calls the setter  

js  

set password(val) {  
  this._password = val;  
}  

Internal Translation  

js  

this._password = password;  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  

3ï¸âƒ£ Where class accessors live  

js  

User.prototype = {  
  get password() {},  
  set password() {}  
}  

ğŸ‘‰ They are NOT on the instance  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  

4ï¸âƒ£ What happens with Object.defineProperty  

âŒ WRONG ORDER  

js  

function Student(name) {  
  this.name = name; // âŒ no setter yet  

  Object.defineProperty(this, 'name', {  
    get() { return `${this._name} Kumar`; },  
    set(val) { this._name = val; }  
  });  
}  

What happens?  

-  this.name = name creates a data property  
-  No setter exists â†’ setter NOT called  
-  Later defineProperty replaces property  
-  _name is never set  

Result    

undefined Kumar  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  

5ï¸âƒ£ âœ… CORRECT ORDER (Your final code)  

js  

function Student(name, className) {  
  this.className = className;  

  Object.defineProperty(this, 'name', {  
    get() {  
      return `${this._name} Kumar`;  
    },  
    set(val) {  
      this._name = val;  
    }  
  });  

  this.name = name; // âœ… setter is called  
}  

Output  

code  

Raman Kumar Raman  

6ï¸âƒ£ Why setter IS called here  

js  

this.name = name;  

At this moment:  

-  name has a setter  
-  JS finds it  
-  Calls setter  
-  _name is set  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  

7ï¸âƒ£ Important Rule (MOST IMPORTANT)  

A setter is called ONLY if it exists at the time of assignment  

Case | Setter Exists? | Setter Called?  
--- | --- | ---  
Assignment before defineProperty | âŒ No | âŒ No  
Assignment after defineProperty | âœ… Yes | âœ… Yes  
class constructor assignment | âœ… Yes | âœ… Yes  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  

8ï¸âƒ£ Getter/Setter lookup order  

When JS executes:  

js  

obj.prop = value;  

JS checks:  

1. Own property setter?  
2. Prototype setter?  
3. Else â†’ create normal property  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  

9ï¸âƒ£ Why this works in class but not function  

Feature | class | defineProperty  
--- | --- | ---  
Accessor location | Prototype | Instance  
Exists before constructor | âœ… Yes | âŒ No  
Order sensitive | âŒ No | âœ… Yes  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  

1ï¸âƒ£0 Data Property vs Accessor Property  

Data property  

js  

{ value: "Raman", writable: true }  

Accessor property  

js  

{ get: f, set: f }  

â— You cannot have both on the same property  

1ï¸âƒ£1 Why value is lost when redefining  

js  

this.name = "Raman";  

Object.defineProperty(this, 'name', { get, set });  

ğŸ‘‰ Old value is discarded  
ğŸ‘‰ JS does NOT migrate data to _name  

Common Traps  

âŒ Expecting setter to run after redefining  
âŒ Assigning before accessor exists  
âŒ Forgetting backing field (_name)  
âŒ Thinking constructor assignment is skipped  

 Interview One-liners   

-  â€œSetters run only if they exist at assignment time.â€  
-  â€œClass accessors live on the prototype.â€  
-  â€œObject.defineProperty is order-dependent.â€  
-  â€œRedefining a property deletes old data.â€
